// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.0--rc3
// source: template.proto

package base

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Base_HealthCheck_FullMethodName = "/base.Base/HealthCheck"
)

// BaseClient is the client API for Base service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BaseClient interface {
	HealthCheck(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*MessageStatusResponse, error)
}

type baseClient struct {
	cc grpc.ClientConnInterface
}

func NewBaseClient(cc grpc.ClientConnInterface) BaseClient {
	return &baseClient{cc}
}

func (c *baseClient) HealthCheck(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*MessageStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MessageStatusResponse)
	err := c.cc.Invoke(ctx, Base_HealthCheck_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BaseServer is the server API for Base service.
// All implementations must embed UnimplementedBaseServer
// for forward compatibility.
type BaseServer interface {
	HealthCheck(context.Context, *emptypb.Empty) (*MessageStatusResponse, error)
	mustEmbedUnimplementedBaseServer()
}

// UnimplementedBaseServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedBaseServer struct{}

func (UnimplementedBaseServer) HealthCheck(context.Context, *emptypb.Empty) (*MessageStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HealthCheck not implemented")
}
func (UnimplementedBaseServer) mustEmbedUnimplementedBaseServer() {}
func (UnimplementedBaseServer) testEmbeddedByValue()              {}

// UnsafeBaseServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BaseServer will
// result in compilation errors.
type UnsafeBaseServer interface {
	mustEmbedUnimplementedBaseServer()
}

func RegisterBaseServer(s grpc.ServiceRegistrar, srv BaseServer) {
	// If the following call pancis, it indicates UnimplementedBaseServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Base_ServiceDesc, srv)
}

func _Base_HealthCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BaseServer).HealthCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Base_HealthCheck_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BaseServer).HealthCheck(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// Base_ServiceDesc is the grpc.ServiceDesc for Base service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Base_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "base.Base",
	HandlerType: (*BaseServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "HealthCheck",
			Handler:    _Base_HealthCheck_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "template.proto",
}

const (
	MataPelajaranService_CreateMataPelajaran_FullMethodName = "/base.MataPelajaranService/CreateMataPelajaran"
	MataPelajaranService_GetMataPelajaran_FullMethodName    = "/base.MataPelajaranService/GetMataPelajaran"
	MataPelajaranService_UpdateMataPelajaran_FullMethodName = "/base.MataPelajaranService/UpdateMataPelajaran"
	MataPelajaranService_DeleteMataPelajaran_FullMethodName = "/base.MataPelajaranService/DeleteMataPelajaran"
	MataPelajaranService_ListMataPelajaran_FullMethodName   = "/base.MataPelajaranService/ListMataPelajaran"
)

// MataPelajaranServiceClient is the client API for MataPelajaranService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MataPelajaranServiceClient interface {
	CreateMataPelajaran(ctx context.Context, in *CreateMataPelajaranRequest, opts ...grpc.CallOption) (*MataPelajaranResponse, error)
	GetMataPelajaran(ctx context.Context, in *GetMataPelajaranRequest, opts ...grpc.CallOption) (*MataPelajaranResponse, error)
	UpdateMataPelajaran(ctx context.Context, in *UpdateMataPelajaranRequest, opts ...grpc.CallOption) (*MataPelajaranResponse, error)
	DeleteMataPelajaran(ctx context.Context, in *DeleteMataPelajaranRequest, opts ...grpc.CallOption) (*MessageStatusResponse, error)
	ListMataPelajaran(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ListMataPelajaranResponse, error)
}

type mataPelajaranServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMataPelajaranServiceClient(cc grpc.ClientConnInterface) MataPelajaranServiceClient {
	return &mataPelajaranServiceClient{cc}
}

func (c *mataPelajaranServiceClient) CreateMataPelajaran(ctx context.Context, in *CreateMataPelajaranRequest, opts ...grpc.CallOption) (*MataPelajaranResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MataPelajaranResponse)
	err := c.cc.Invoke(ctx, MataPelajaranService_CreateMataPelajaran_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mataPelajaranServiceClient) GetMataPelajaran(ctx context.Context, in *GetMataPelajaranRequest, opts ...grpc.CallOption) (*MataPelajaranResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MataPelajaranResponse)
	err := c.cc.Invoke(ctx, MataPelajaranService_GetMataPelajaran_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mataPelajaranServiceClient) UpdateMataPelajaran(ctx context.Context, in *UpdateMataPelajaranRequest, opts ...grpc.CallOption) (*MataPelajaranResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MataPelajaranResponse)
	err := c.cc.Invoke(ctx, MataPelajaranService_UpdateMataPelajaran_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mataPelajaranServiceClient) DeleteMataPelajaran(ctx context.Context, in *DeleteMataPelajaranRequest, opts ...grpc.CallOption) (*MessageStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MessageStatusResponse)
	err := c.cc.Invoke(ctx, MataPelajaranService_DeleteMataPelajaran_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mataPelajaranServiceClient) ListMataPelajaran(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ListMataPelajaranResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListMataPelajaranResponse)
	err := c.cc.Invoke(ctx, MataPelajaranService_ListMataPelajaran_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MataPelajaranServiceServer is the server API for MataPelajaranService service.
// All implementations must embed UnimplementedMataPelajaranServiceServer
// for forward compatibility.
type MataPelajaranServiceServer interface {
	CreateMataPelajaran(context.Context, *CreateMataPelajaranRequest) (*MataPelajaranResponse, error)
	GetMataPelajaran(context.Context, *GetMataPelajaranRequest) (*MataPelajaranResponse, error)
	UpdateMataPelajaran(context.Context, *UpdateMataPelajaranRequest) (*MataPelajaranResponse, error)
	DeleteMataPelajaran(context.Context, *DeleteMataPelajaranRequest) (*MessageStatusResponse, error)
	ListMataPelajaran(context.Context, *emptypb.Empty) (*ListMataPelajaranResponse, error)
	mustEmbedUnimplementedMataPelajaranServiceServer()
}

// UnimplementedMataPelajaranServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMataPelajaranServiceServer struct{}

func (UnimplementedMataPelajaranServiceServer) CreateMataPelajaran(context.Context, *CreateMataPelajaranRequest) (*MataPelajaranResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateMataPelajaran not implemented")
}
func (UnimplementedMataPelajaranServiceServer) GetMataPelajaran(context.Context, *GetMataPelajaranRequest) (*MataPelajaranResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMataPelajaran not implemented")
}
func (UnimplementedMataPelajaranServiceServer) UpdateMataPelajaran(context.Context, *UpdateMataPelajaranRequest) (*MataPelajaranResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateMataPelajaran not implemented")
}
func (UnimplementedMataPelajaranServiceServer) DeleteMataPelajaran(context.Context, *DeleteMataPelajaranRequest) (*MessageStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteMataPelajaran not implemented")
}
func (UnimplementedMataPelajaranServiceServer) ListMataPelajaran(context.Context, *emptypb.Empty) (*ListMataPelajaranResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListMataPelajaran not implemented")
}
func (UnimplementedMataPelajaranServiceServer) mustEmbedUnimplementedMataPelajaranServiceServer() {}
func (UnimplementedMataPelajaranServiceServer) testEmbeddedByValue()                              {}

// UnsafeMataPelajaranServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MataPelajaranServiceServer will
// result in compilation errors.
type UnsafeMataPelajaranServiceServer interface {
	mustEmbedUnimplementedMataPelajaranServiceServer()
}

func RegisterMataPelajaranServiceServer(s grpc.ServiceRegistrar, srv MataPelajaranServiceServer) {
	// If the following call pancis, it indicates UnimplementedMataPelajaranServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&MataPelajaranService_ServiceDesc, srv)
}

func _MataPelajaranService_CreateMataPelajaran_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateMataPelajaranRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MataPelajaranServiceServer).CreateMataPelajaran(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MataPelajaranService_CreateMataPelajaran_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MataPelajaranServiceServer).CreateMataPelajaran(ctx, req.(*CreateMataPelajaranRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MataPelajaranService_GetMataPelajaran_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMataPelajaranRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MataPelajaranServiceServer).GetMataPelajaran(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MataPelajaranService_GetMataPelajaran_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MataPelajaranServiceServer).GetMataPelajaran(ctx, req.(*GetMataPelajaranRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MataPelajaranService_UpdateMataPelajaran_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateMataPelajaranRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MataPelajaranServiceServer).UpdateMataPelajaran(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MataPelajaranService_UpdateMataPelajaran_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MataPelajaranServiceServer).UpdateMataPelajaran(ctx, req.(*UpdateMataPelajaranRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MataPelajaranService_DeleteMataPelajaran_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteMataPelajaranRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MataPelajaranServiceServer).DeleteMataPelajaran(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MataPelajaranService_DeleteMataPelajaran_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MataPelajaranServiceServer).DeleteMataPelajaran(ctx, req.(*DeleteMataPelajaranRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MataPelajaranService_ListMataPelajaran_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MataPelajaranServiceServer).ListMataPelajaran(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MataPelajaranService_ListMataPelajaran_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MataPelajaranServiceServer).ListMataPelajaran(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// MataPelajaranService_ServiceDesc is the grpc.ServiceDesc for MataPelajaranService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MataPelajaranService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "base.MataPelajaranService",
	HandlerType: (*MataPelajaranServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateMataPelajaran",
			Handler:    _MataPelajaranService_CreateMataPelajaran_Handler,
		},
		{
			MethodName: "GetMataPelajaran",
			Handler:    _MataPelajaranService_GetMataPelajaran_Handler,
		},
		{
			MethodName: "UpdateMataPelajaran",
			Handler:    _MataPelajaranService_UpdateMataPelajaran_Handler,
		},
		{
			MethodName: "DeleteMataPelajaran",
			Handler:    _MataPelajaranService_DeleteMataPelajaran_Handler,
		},
		{
			MethodName: "ListMataPelajaran",
			Handler:    _MataPelajaranService_ListMataPelajaran_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "template.proto",
}

const (
	MateriService_CreateMateri_FullMethodName = "/base.MateriService/CreateMateri"
	MateriService_GetMateri_FullMethodName    = "/base.MateriService/GetMateri"
	MateriService_UpdateMateri_FullMethodName = "/base.MateriService/UpdateMateri"
	MateriService_DeleteMateri_FullMethodName = "/base.MateriService/DeleteMateri"
	MateriService_ListMateri_FullMethodName   = "/base.MateriService/ListMateri"
)

// MateriServiceClient is the client API for MateriService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MateriServiceClient interface {
	CreateMateri(ctx context.Context, in *CreateMateriRequest, opts ...grpc.CallOption) (*MateriResponse, error)
	GetMateri(ctx context.Context, in *GetMateriRequest, opts ...grpc.CallOption) (*MateriResponse, error)
	UpdateMateri(ctx context.Context, in *UpdateMateriRequest, opts ...grpc.CallOption) (*MateriResponse, error)
	DeleteMateri(ctx context.Context, in *DeleteMateriRequest, opts ...grpc.CallOption) (*MessageStatusResponse, error)
	ListMateri(ctx context.Context, in *ListMateriRequest, opts ...grpc.CallOption) (*ListMateriResponse, error)
}

type materiServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMateriServiceClient(cc grpc.ClientConnInterface) MateriServiceClient {
	return &materiServiceClient{cc}
}

func (c *materiServiceClient) CreateMateri(ctx context.Context, in *CreateMateriRequest, opts ...grpc.CallOption) (*MateriResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MateriResponse)
	err := c.cc.Invoke(ctx, MateriService_CreateMateri_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *materiServiceClient) GetMateri(ctx context.Context, in *GetMateriRequest, opts ...grpc.CallOption) (*MateriResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MateriResponse)
	err := c.cc.Invoke(ctx, MateriService_GetMateri_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *materiServiceClient) UpdateMateri(ctx context.Context, in *UpdateMateriRequest, opts ...grpc.CallOption) (*MateriResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MateriResponse)
	err := c.cc.Invoke(ctx, MateriService_UpdateMateri_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *materiServiceClient) DeleteMateri(ctx context.Context, in *DeleteMateriRequest, opts ...grpc.CallOption) (*MessageStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MessageStatusResponse)
	err := c.cc.Invoke(ctx, MateriService_DeleteMateri_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *materiServiceClient) ListMateri(ctx context.Context, in *ListMateriRequest, opts ...grpc.CallOption) (*ListMateriResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListMateriResponse)
	err := c.cc.Invoke(ctx, MateriService_ListMateri_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MateriServiceServer is the server API for MateriService service.
// All implementations must embed UnimplementedMateriServiceServer
// for forward compatibility.
type MateriServiceServer interface {
	CreateMateri(context.Context, *CreateMateriRequest) (*MateriResponse, error)
	GetMateri(context.Context, *GetMateriRequest) (*MateriResponse, error)
	UpdateMateri(context.Context, *UpdateMateriRequest) (*MateriResponse, error)
	DeleteMateri(context.Context, *DeleteMateriRequest) (*MessageStatusResponse, error)
	ListMateri(context.Context, *ListMateriRequest) (*ListMateriResponse, error)
	mustEmbedUnimplementedMateriServiceServer()
}

// UnimplementedMateriServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMateriServiceServer struct{}

func (UnimplementedMateriServiceServer) CreateMateri(context.Context, *CreateMateriRequest) (*MateriResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateMateri not implemented")
}
func (UnimplementedMateriServiceServer) GetMateri(context.Context, *GetMateriRequest) (*MateriResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMateri not implemented")
}
func (UnimplementedMateriServiceServer) UpdateMateri(context.Context, *UpdateMateriRequest) (*MateriResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateMateri not implemented")
}
func (UnimplementedMateriServiceServer) DeleteMateri(context.Context, *DeleteMateriRequest) (*MessageStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteMateri not implemented")
}
func (UnimplementedMateriServiceServer) ListMateri(context.Context, *ListMateriRequest) (*ListMateriResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListMateri not implemented")
}
func (UnimplementedMateriServiceServer) mustEmbedUnimplementedMateriServiceServer() {}
func (UnimplementedMateriServiceServer) testEmbeddedByValue()                       {}

// UnsafeMateriServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MateriServiceServer will
// result in compilation errors.
type UnsafeMateriServiceServer interface {
	mustEmbedUnimplementedMateriServiceServer()
}

func RegisterMateriServiceServer(s grpc.ServiceRegistrar, srv MateriServiceServer) {
	// If the following call pancis, it indicates UnimplementedMateriServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&MateriService_ServiceDesc, srv)
}

func _MateriService_CreateMateri_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateMateriRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MateriServiceServer).CreateMateri(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MateriService_CreateMateri_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MateriServiceServer).CreateMateri(ctx, req.(*CreateMateriRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MateriService_GetMateri_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMateriRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MateriServiceServer).GetMateri(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MateriService_GetMateri_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MateriServiceServer).GetMateri(ctx, req.(*GetMateriRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MateriService_UpdateMateri_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateMateriRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MateriServiceServer).UpdateMateri(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MateriService_UpdateMateri_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MateriServiceServer).UpdateMateri(ctx, req.(*UpdateMateriRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MateriService_DeleteMateri_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteMateriRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MateriServiceServer).DeleteMateri(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MateriService_DeleteMateri_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MateriServiceServer).DeleteMateri(ctx, req.(*DeleteMateriRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MateriService_ListMateri_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListMateriRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MateriServiceServer).ListMateri(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MateriService_ListMateri_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MateriServiceServer).ListMateri(ctx, req.(*ListMateriRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// MateriService_ServiceDesc is the grpc.ServiceDesc for MateriService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MateriService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "base.MateriService",
	HandlerType: (*MateriServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateMateri",
			Handler:    _MateriService_CreateMateri_Handler,
		},
		{
			MethodName: "GetMateri",
			Handler:    _MateriService_GetMateri_Handler,
		},
		{
			MethodName: "UpdateMateri",
			Handler:    _MateriService_UpdateMateri_Handler,
		},
		{
			MethodName: "DeleteMateri",
			Handler:    _MateriService_DeleteMateri_Handler,
		},
		{
			MethodName: "ListMateri",
			Handler:    _MateriService_ListMateri_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "template.proto",
}

const (
	TingkatService_CreateTingkat_FullMethodName = "/base.TingkatService/CreateTingkat"
	TingkatService_GetTingkat_FullMethodName    = "/base.TingkatService/GetTingkat"
	TingkatService_UpdateTingkat_FullMethodName = "/base.TingkatService/UpdateTingkat"
	TingkatService_DeleteTingkat_FullMethodName = "/base.TingkatService/DeleteTingkat"
	TingkatService_ListTingkat_FullMethodName   = "/base.TingkatService/ListTingkat"
)

// TingkatServiceClient is the client API for TingkatService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TingkatServiceClient interface {
	CreateTingkat(ctx context.Context, in *CreateTingkatRequest, opts ...grpc.CallOption) (*TingkatResponse, error)
	GetTingkat(ctx context.Context, in *GetTingkatRequest, opts ...grpc.CallOption) (*TingkatResponse, error)
	UpdateTingkat(ctx context.Context, in *UpdateTingkatRequest, opts ...grpc.CallOption) (*TingkatResponse, error)
	DeleteTingkat(ctx context.Context, in *DeleteTingkatRequest, opts ...grpc.CallOption) (*MessageStatusResponse, error)
	ListTingkat(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ListTingkatResponse, error)
}

type tingkatServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTingkatServiceClient(cc grpc.ClientConnInterface) TingkatServiceClient {
	return &tingkatServiceClient{cc}
}

func (c *tingkatServiceClient) CreateTingkat(ctx context.Context, in *CreateTingkatRequest, opts ...grpc.CallOption) (*TingkatResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TingkatResponse)
	err := c.cc.Invoke(ctx, TingkatService_CreateTingkat_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tingkatServiceClient) GetTingkat(ctx context.Context, in *GetTingkatRequest, opts ...grpc.CallOption) (*TingkatResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TingkatResponse)
	err := c.cc.Invoke(ctx, TingkatService_GetTingkat_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tingkatServiceClient) UpdateTingkat(ctx context.Context, in *UpdateTingkatRequest, opts ...grpc.CallOption) (*TingkatResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TingkatResponse)
	err := c.cc.Invoke(ctx, TingkatService_UpdateTingkat_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tingkatServiceClient) DeleteTingkat(ctx context.Context, in *DeleteTingkatRequest, opts ...grpc.CallOption) (*MessageStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MessageStatusResponse)
	err := c.cc.Invoke(ctx, TingkatService_DeleteTingkat_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tingkatServiceClient) ListTingkat(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ListTingkatResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListTingkatResponse)
	err := c.cc.Invoke(ctx, TingkatService_ListTingkat_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TingkatServiceServer is the server API for TingkatService service.
// All implementations must embed UnimplementedTingkatServiceServer
// for forward compatibility.
type TingkatServiceServer interface {
	CreateTingkat(context.Context, *CreateTingkatRequest) (*TingkatResponse, error)
	GetTingkat(context.Context, *GetTingkatRequest) (*TingkatResponse, error)
	UpdateTingkat(context.Context, *UpdateTingkatRequest) (*TingkatResponse, error)
	DeleteTingkat(context.Context, *DeleteTingkatRequest) (*MessageStatusResponse, error)
	ListTingkat(context.Context, *emptypb.Empty) (*ListTingkatResponse, error)
	mustEmbedUnimplementedTingkatServiceServer()
}

// UnimplementedTingkatServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedTingkatServiceServer struct{}

func (UnimplementedTingkatServiceServer) CreateTingkat(context.Context, *CreateTingkatRequest) (*TingkatResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateTingkat not implemented")
}
func (UnimplementedTingkatServiceServer) GetTingkat(context.Context, *GetTingkatRequest) (*TingkatResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTingkat not implemented")
}
func (UnimplementedTingkatServiceServer) UpdateTingkat(context.Context, *UpdateTingkatRequest) (*TingkatResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateTingkat not implemented")
}
func (UnimplementedTingkatServiceServer) DeleteTingkat(context.Context, *DeleteTingkatRequest) (*MessageStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteTingkat not implemented")
}
func (UnimplementedTingkatServiceServer) ListTingkat(context.Context, *emptypb.Empty) (*ListTingkatResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTingkat not implemented")
}
func (UnimplementedTingkatServiceServer) mustEmbedUnimplementedTingkatServiceServer() {}
func (UnimplementedTingkatServiceServer) testEmbeddedByValue()                        {}

// UnsafeTingkatServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TingkatServiceServer will
// result in compilation errors.
type UnsafeTingkatServiceServer interface {
	mustEmbedUnimplementedTingkatServiceServer()
}

func RegisterTingkatServiceServer(s grpc.ServiceRegistrar, srv TingkatServiceServer) {
	// If the following call pancis, it indicates UnimplementedTingkatServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&TingkatService_ServiceDesc, srv)
}

func _TingkatService_CreateTingkat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateTingkatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TingkatServiceServer).CreateTingkat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TingkatService_CreateTingkat_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TingkatServiceServer).CreateTingkat(ctx, req.(*CreateTingkatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TingkatService_GetTingkat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTingkatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TingkatServiceServer).GetTingkat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TingkatService_GetTingkat_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TingkatServiceServer).GetTingkat(ctx, req.(*GetTingkatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TingkatService_UpdateTingkat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateTingkatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TingkatServiceServer).UpdateTingkat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TingkatService_UpdateTingkat_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TingkatServiceServer).UpdateTingkat(ctx, req.(*UpdateTingkatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TingkatService_DeleteTingkat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteTingkatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TingkatServiceServer).DeleteTingkat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TingkatService_DeleteTingkat_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TingkatServiceServer).DeleteTingkat(ctx, req.(*DeleteTingkatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TingkatService_ListTingkat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TingkatServiceServer).ListTingkat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TingkatService_ListTingkat_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TingkatServiceServer).ListTingkat(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// TingkatService_ServiceDesc is the grpc.ServiceDesc for TingkatService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TingkatService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "base.TingkatService",
	HandlerType: (*TingkatServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateTingkat",
			Handler:    _TingkatService_CreateTingkat_Handler,
		},
		{
			MethodName: "GetTingkat",
			Handler:    _TingkatService_GetTingkat_Handler,
		},
		{
			MethodName: "UpdateTingkat",
			Handler:    _TingkatService_UpdateTingkat_Handler,
		},
		{
			MethodName: "DeleteTingkat",
			Handler:    _TingkatService_DeleteTingkat_Handler,
		},
		{
			MethodName: "ListTingkat",
			Handler:    _TingkatService_ListTingkat_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "template.proto",
}

const (
	SoalService_CreateSoal_FullMethodName          = "/base.SoalService/CreateSoal"
	SoalService_GetSoal_FullMethodName             = "/base.SoalService/GetSoal"
	SoalService_UpdateSoal_FullMethodName          = "/base.SoalService/UpdateSoal"
	SoalService_DeleteSoal_FullMethodName          = "/base.SoalService/DeleteSoal"
	SoalService_ListSoal_FullMethodName            = "/base.SoalService/ListSoal"
	SoalService_UploadImageToSoal_FullMethodName   = "/base.SoalService/UploadImageToSoal"
	SoalService_DeleteImageFromSoal_FullMethodName = "/base.SoalService/DeleteImageFromSoal"
	SoalService_UpdateImageInSoal_FullMethodName   = "/base.SoalService/UpdateImageInSoal"
)

// SoalServiceClient is the client API for SoalService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SoalServiceClient interface {
	CreateSoal(ctx context.Context, in *CreateSoalRequest, opts ...grpc.CallOption) (*SoalResponse, error)
	GetSoal(ctx context.Context, in *GetSoalRequest, opts ...grpc.CallOption) (*SoalResponse, error)
	UpdateSoal(ctx context.Context, in *UpdateSoalRequest, opts ...grpc.CallOption) (*SoalResponse, error)
	DeleteSoal(ctx context.Context, in *DeleteSoalRequest, opts ...grpc.CallOption) (*MessageStatusResponse, error)
	ListSoal(ctx context.Context, in *ListSoalRequest, opts ...grpc.CallOption) (*ListSoalResponse, error)
	UploadImageToSoal(ctx context.Context, in *UploadImageToSoalRequest, opts ...grpc.CallOption) (*UploadImageResponse, error)
	DeleteImageFromSoal(ctx context.Context, in *DeleteImageFromSoalRequest, opts ...grpc.CallOption) (*MessageStatusResponse, error)
	UpdateImageInSoal(ctx context.Context, in *UpdateImageInSoalRequest, opts ...grpc.CallOption) (*MessageStatusResponse, error)
}

type soalServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSoalServiceClient(cc grpc.ClientConnInterface) SoalServiceClient {
	return &soalServiceClient{cc}
}

func (c *soalServiceClient) CreateSoal(ctx context.Context, in *CreateSoalRequest, opts ...grpc.CallOption) (*SoalResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SoalResponse)
	err := c.cc.Invoke(ctx, SoalService_CreateSoal_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *soalServiceClient) GetSoal(ctx context.Context, in *GetSoalRequest, opts ...grpc.CallOption) (*SoalResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SoalResponse)
	err := c.cc.Invoke(ctx, SoalService_GetSoal_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *soalServiceClient) UpdateSoal(ctx context.Context, in *UpdateSoalRequest, opts ...grpc.CallOption) (*SoalResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SoalResponse)
	err := c.cc.Invoke(ctx, SoalService_UpdateSoal_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *soalServiceClient) DeleteSoal(ctx context.Context, in *DeleteSoalRequest, opts ...grpc.CallOption) (*MessageStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MessageStatusResponse)
	err := c.cc.Invoke(ctx, SoalService_DeleteSoal_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *soalServiceClient) ListSoal(ctx context.Context, in *ListSoalRequest, opts ...grpc.CallOption) (*ListSoalResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListSoalResponse)
	err := c.cc.Invoke(ctx, SoalService_ListSoal_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *soalServiceClient) UploadImageToSoal(ctx context.Context, in *UploadImageToSoalRequest, opts ...grpc.CallOption) (*UploadImageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UploadImageResponse)
	err := c.cc.Invoke(ctx, SoalService_UploadImageToSoal_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *soalServiceClient) DeleteImageFromSoal(ctx context.Context, in *DeleteImageFromSoalRequest, opts ...grpc.CallOption) (*MessageStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MessageStatusResponse)
	err := c.cc.Invoke(ctx, SoalService_DeleteImageFromSoal_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *soalServiceClient) UpdateImageInSoal(ctx context.Context, in *UpdateImageInSoalRequest, opts ...grpc.CallOption) (*MessageStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MessageStatusResponse)
	err := c.cc.Invoke(ctx, SoalService_UpdateImageInSoal_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SoalServiceServer is the server API for SoalService service.
// All implementations must embed UnimplementedSoalServiceServer
// for forward compatibility.
type SoalServiceServer interface {
	CreateSoal(context.Context, *CreateSoalRequest) (*SoalResponse, error)
	GetSoal(context.Context, *GetSoalRequest) (*SoalResponse, error)
	UpdateSoal(context.Context, *UpdateSoalRequest) (*SoalResponse, error)
	DeleteSoal(context.Context, *DeleteSoalRequest) (*MessageStatusResponse, error)
	ListSoal(context.Context, *ListSoalRequest) (*ListSoalResponse, error)
	UploadImageToSoal(context.Context, *UploadImageToSoalRequest) (*UploadImageResponse, error)
	DeleteImageFromSoal(context.Context, *DeleteImageFromSoalRequest) (*MessageStatusResponse, error)
	UpdateImageInSoal(context.Context, *UpdateImageInSoalRequest) (*MessageStatusResponse, error)
	mustEmbedUnimplementedSoalServiceServer()
}

// UnimplementedSoalServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSoalServiceServer struct{}

func (UnimplementedSoalServiceServer) CreateSoal(context.Context, *CreateSoalRequest) (*SoalResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateSoal not implemented")
}
func (UnimplementedSoalServiceServer) GetSoal(context.Context, *GetSoalRequest) (*SoalResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSoal not implemented")
}
func (UnimplementedSoalServiceServer) UpdateSoal(context.Context, *UpdateSoalRequest) (*SoalResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateSoal not implemented")
}
func (UnimplementedSoalServiceServer) DeleteSoal(context.Context, *DeleteSoalRequest) (*MessageStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteSoal not implemented")
}
func (UnimplementedSoalServiceServer) ListSoal(context.Context, *ListSoalRequest) (*ListSoalResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListSoal not implemented")
}
func (UnimplementedSoalServiceServer) UploadImageToSoal(context.Context, *UploadImageToSoalRequest) (*UploadImageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UploadImageToSoal not implemented")
}
func (UnimplementedSoalServiceServer) DeleteImageFromSoal(context.Context, *DeleteImageFromSoalRequest) (*MessageStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteImageFromSoal not implemented")
}
func (UnimplementedSoalServiceServer) UpdateImageInSoal(context.Context, *UpdateImageInSoalRequest) (*MessageStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateImageInSoal not implemented")
}
func (UnimplementedSoalServiceServer) mustEmbedUnimplementedSoalServiceServer() {}
func (UnimplementedSoalServiceServer) testEmbeddedByValue()                     {}

// UnsafeSoalServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SoalServiceServer will
// result in compilation errors.
type UnsafeSoalServiceServer interface {
	mustEmbedUnimplementedSoalServiceServer()
}

func RegisterSoalServiceServer(s grpc.ServiceRegistrar, srv SoalServiceServer) {
	// If the following call pancis, it indicates UnimplementedSoalServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&SoalService_ServiceDesc, srv)
}

func _SoalService_CreateSoal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateSoalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SoalServiceServer).CreateSoal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SoalService_CreateSoal_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SoalServiceServer).CreateSoal(ctx, req.(*CreateSoalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SoalService_GetSoal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSoalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SoalServiceServer).GetSoal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SoalService_GetSoal_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SoalServiceServer).GetSoal(ctx, req.(*GetSoalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SoalService_UpdateSoal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateSoalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SoalServiceServer).UpdateSoal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SoalService_UpdateSoal_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SoalServiceServer).UpdateSoal(ctx, req.(*UpdateSoalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SoalService_DeleteSoal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteSoalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SoalServiceServer).DeleteSoal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SoalService_DeleteSoal_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SoalServiceServer).DeleteSoal(ctx, req.(*DeleteSoalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SoalService_ListSoal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListSoalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SoalServiceServer).ListSoal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SoalService_ListSoal_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SoalServiceServer).ListSoal(ctx, req.(*ListSoalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SoalService_UploadImageToSoal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UploadImageToSoalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SoalServiceServer).UploadImageToSoal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SoalService_UploadImageToSoal_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SoalServiceServer).UploadImageToSoal(ctx, req.(*UploadImageToSoalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SoalService_DeleteImageFromSoal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteImageFromSoalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SoalServiceServer).DeleteImageFromSoal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SoalService_DeleteImageFromSoal_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SoalServiceServer).DeleteImageFromSoal(ctx, req.(*DeleteImageFromSoalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SoalService_UpdateImageInSoal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateImageInSoalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SoalServiceServer).UpdateImageInSoal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SoalService_UpdateImageInSoal_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SoalServiceServer).UpdateImageInSoal(ctx, req.(*UpdateImageInSoalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SoalService_ServiceDesc is the grpc.ServiceDesc for SoalService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SoalService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "base.SoalService",
	HandlerType: (*SoalServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateSoal",
			Handler:    _SoalService_CreateSoal_Handler,
		},
		{
			MethodName: "GetSoal",
			Handler:    _SoalService_GetSoal_Handler,
		},
		{
			MethodName: "UpdateSoal",
			Handler:    _SoalService_UpdateSoal_Handler,
		},
		{
			MethodName: "DeleteSoal",
			Handler:    _SoalService_DeleteSoal_Handler,
		},
		{
			MethodName: "ListSoal",
			Handler:    _SoalService_ListSoal_Handler,
		},
		{
			MethodName: "UploadImageToSoal",
			Handler:    _SoalService_UploadImageToSoal_Handler,
		},
		{
			MethodName: "DeleteImageFromSoal",
			Handler:    _SoalService_DeleteImageFromSoal_Handler,
		},
		{
			MethodName: "UpdateImageInSoal",
			Handler:    _SoalService_UpdateImageInSoal_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "template.proto",
}

const (
	TestSessionService_CreateTestSession_FullMethodName = "/base.TestSessionService/CreateTestSession"
	TestSessionService_GetTestSession_FullMethodName    = "/base.TestSessionService/GetTestSession"
	TestSessionService_GetTestQuestions_FullMethodName  = "/base.TestSessionService/GetTestQuestions"
	TestSessionService_SubmitAnswer_FullMethodName      = "/base.TestSessionService/SubmitAnswer"
	TestSessionService_ClearAnswer_FullMethodName       = "/base.TestSessionService/ClearAnswer"
	TestSessionService_CompleteSession_FullMethodName   = "/base.TestSessionService/CompleteSession"
	TestSessionService_GetTestResult_FullMethodName     = "/base.TestSessionService/GetTestResult"
	TestSessionService_ListTestSessions_FullMethodName  = "/base.TestSessionService/ListTestSessions"
)

// TestSessionServiceClient is the client API for TestSessionService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TestSessionServiceClient interface {
	// Session management
	CreateTestSession(ctx context.Context, in *CreateTestSessionRequest, opts ...grpc.CallOption) (*TestSessionResponse, error)
	GetTestSession(ctx context.Context, in *GetTestSessionRequest, opts ...grpc.CallOption) (*TestSessionResponse, error)
	// Test execution (NEW - critical!)
	GetTestQuestions(ctx context.Context, in *GetTestQuestionsRequest, opts ...grpc.CallOption) (*TestQuestionsResponse, error)
	SubmitAnswer(ctx context.Context, in *SubmitAnswerRequest, opts ...grpc.CallOption) (*SubmitAnswerResponse, error)
	ClearAnswer(ctx context.Context, in *ClearAnswerRequest, opts ...grpc.CallOption) (*ClearAnswerResponse, error)
	CompleteSession(ctx context.Context, in *CompleteSessionRequest, opts ...grpc.CallOption) (*TestSessionResponse, error)
	// Results & review
	GetTestResult(ctx context.Context, in *GetTestResultRequest, opts ...grpc.CallOption) (*TestResultResponse, error)
	// Admin queries
	ListTestSessions(ctx context.Context, in *ListTestSessionsRequest, opts ...grpc.CallOption) (*ListTestSessionsResponse, error)
}

type testSessionServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTestSessionServiceClient(cc grpc.ClientConnInterface) TestSessionServiceClient {
	return &testSessionServiceClient{cc}
}

func (c *testSessionServiceClient) CreateTestSession(ctx context.Context, in *CreateTestSessionRequest, opts ...grpc.CallOption) (*TestSessionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TestSessionResponse)
	err := c.cc.Invoke(ctx, TestSessionService_CreateTestSession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *testSessionServiceClient) GetTestSession(ctx context.Context, in *GetTestSessionRequest, opts ...grpc.CallOption) (*TestSessionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TestSessionResponse)
	err := c.cc.Invoke(ctx, TestSessionService_GetTestSession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *testSessionServiceClient) GetTestQuestions(ctx context.Context, in *GetTestQuestionsRequest, opts ...grpc.CallOption) (*TestQuestionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TestQuestionsResponse)
	err := c.cc.Invoke(ctx, TestSessionService_GetTestQuestions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *testSessionServiceClient) SubmitAnswer(ctx context.Context, in *SubmitAnswerRequest, opts ...grpc.CallOption) (*SubmitAnswerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SubmitAnswerResponse)
	err := c.cc.Invoke(ctx, TestSessionService_SubmitAnswer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *testSessionServiceClient) ClearAnswer(ctx context.Context, in *ClearAnswerRequest, opts ...grpc.CallOption) (*ClearAnswerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClearAnswerResponse)
	err := c.cc.Invoke(ctx, TestSessionService_ClearAnswer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *testSessionServiceClient) CompleteSession(ctx context.Context, in *CompleteSessionRequest, opts ...grpc.CallOption) (*TestSessionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TestSessionResponse)
	err := c.cc.Invoke(ctx, TestSessionService_CompleteSession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *testSessionServiceClient) GetTestResult(ctx context.Context, in *GetTestResultRequest, opts ...grpc.CallOption) (*TestResultResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TestResultResponse)
	err := c.cc.Invoke(ctx, TestSessionService_GetTestResult_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *testSessionServiceClient) ListTestSessions(ctx context.Context, in *ListTestSessionsRequest, opts ...grpc.CallOption) (*ListTestSessionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListTestSessionsResponse)
	err := c.cc.Invoke(ctx, TestSessionService_ListTestSessions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TestSessionServiceServer is the server API for TestSessionService service.
// All implementations must embed UnimplementedTestSessionServiceServer
// for forward compatibility.
type TestSessionServiceServer interface {
	// Session management
	CreateTestSession(context.Context, *CreateTestSessionRequest) (*TestSessionResponse, error)
	GetTestSession(context.Context, *GetTestSessionRequest) (*TestSessionResponse, error)
	// Test execution (NEW - critical!)
	GetTestQuestions(context.Context, *GetTestQuestionsRequest) (*TestQuestionsResponse, error)
	SubmitAnswer(context.Context, *SubmitAnswerRequest) (*SubmitAnswerResponse, error)
	ClearAnswer(context.Context, *ClearAnswerRequest) (*ClearAnswerResponse, error)
	CompleteSession(context.Context, *CompleteSessionRequest) (*TestSessionResponse, error)
	// Results & review
	GetTestResult(context.Context, *GetTestResultRequest) (*TestResultResponse, error)
	// Admin queries
	ListTestSessions(context.Context, *ListTestSessionsRequest) (*ListTestSessionsResponse, error)
	mustEmbedUnimplementedTestSessionServiceServer()
}

// UnimplementedTestSessionServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedTestSessionServiceServer struct{}

func (UnimplementedTestSessionServiceServer) CreateTestSession(context.Context, *CreateTestSessionRequest) (*TestSessionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateTestSession not implemented")
}
func (UnimplementedTestSessionServiceServer) GetTestSession(context.Context, *GetTestSessionRequest) (*TestSessionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTestSession not implemented")
}
func (UnimplementedTestSessionServiceServer) GetTestQuestions(context.Context, *GetTestQuestionsRequest) (*TestQuestionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTestQuestions not implemented")
}
func (UnimplementedTestSessionServiceServer) SubmitAnswer(context.Context, *SubmitAnswerRequest) (*SubmitAnswerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitAnswer not implemented")
}
func (UnimplementedTestSessionServiceServer) ClearAnswer(context.Context, *ClearAnswerRequest) (*ClearAnswerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClearAnswer not implemented")
}
func (UnimplementedTestSessionServiceServer) CompleteSession(context.Context, *CompleteSessionRequest) (*TestSessionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CompleteSession not implemented")
}
func (UnimplementedTestSessionServiceServer) GetTestResult(context.Context, *GetTestResultRequest) (*TestResultResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTestResult not implemented")
}
func (UnimplementedTestSessionServiceServer) ListTestSessions(context.Context, *ListTestSessionsRequest) (*ListTestSessionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTestSessions not implemented")
}
func (UnimplementedTestSessionServiceServer) mustEmbedUnimplementedTestSessionServiceServer() {}
func (UnimplementedTestSessionServiceServer) testEmbeddedByValue()                            {}

// UnsafeTestSessionServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TestSessionServiceServer will
// result in compilation errors.
type UnsafeTestSessionServiceServer interface {
	mustEmbedUnimplementedTestSessionServiceServer()
}

func RegisterTestSessionServiceServer(s grpc.ServiceRegistrar, srv TestSessionServiceServer) {
	// If the following call pancis, it indicates UnimplementedTestSessionServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&TestSessionService_ServiceDesc, srv)
}

func _TestSessionService_CreateTestSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateTestSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TestSessionServiceServer).CreateTestSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TestSessionService_CreateTestSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TestSessionServiceServer).CreateTestSession(ctx, req.(*CreateTestSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TestSessionService_GetTestSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTestSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TestSessionServiceServer).GetTestSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TestSessionService_GetTestSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TestSessionServiceServer).GetTestSession(ctx, req.(*GetTestSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TestSessionService_GetTestQuestions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTestQuestionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TestSessionServiceServer).GetTestQuestions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TestSessionService_GetTestQuestions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TestSessionServiceServer).GetTestQuestions(ctx, req.(*GetTestQuestionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TestSessionService_SubmitAnswer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubmitAnswerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TestSessionServiceServer).SubmitAnswer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TestSessionService_SubmitAnswer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TestSessionServiceServer).SubmitAnswer(ctx, req.(*SubmitAnswerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TestSessionService_ClearAnswer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClearAnswerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TestSessionServiceServer).ClearAnswer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TestSessionService_ClearAnswer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TestSessionServiceServer).ClearAnswer(ctx, req.(*ClearAnswerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TestSessionService_CompleteSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CompleteSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TestSessionServiceServer).CompleteSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TestSessionService_CompleteSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TestSessionServiceServer).CompleteSession(ctx, req.(*CompleteSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TestSessionService_GetTestResult_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTestResultRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TestSessionServiceServer).GetTestResult(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TestSessionService_GetTestResult_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TestSessionServiceServer).GetTestResult(ctx, req.(*GetTestResultRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TestSessionService_ListTestSessions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTestSessionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TestSessionServiceServer).ListTestSessions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TestSessionService_ListTestSessions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TestSessionServiceServer).ListTestSessions(ctx, req.(*ListTestSessionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// TestSessionService_ServiceDesc is the grpc.ServiceDesc for TestSessionService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TestSessionService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "base.TestSessionService",
	HandlerType: (*TestSessionServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateTestSession",
			Handler:    _TestSessionService_CreateTestSession_Handler,
		},
		{
			MethodName: "GetTestSession",
			Handler:    _TestSessionService_GetTestSession_Handler,
		},
		{
			MethodName: "GetTestQuestions",
			Handler:    _TestSessionService_GetTestQuestions_Handler,
		},
		{
			MethodName: "SubmitAnswer",
			Handler:    _TestSessionService_SubmitAnswer_Handler,
		},
		{
			MethodName: "ClearAnswer",
			Handler:    _TestSessionService_ClearAnswer_Handler,
		},
		{
			MethodName: "CompleteSession",
			Handler:    _TestSessionService_CompleteSession_Handler,
		},
		{
			MethodName: "GetTestResult",
			Handler:    _TestSessionService_GetTestResult_Handler,
		},
		{
			MethodName: "ListTestSessions",
			Handler:    _TestSessionService_ListTestSessions_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "template.proto",
}

const (
	HistoryService_GetStudentHistory_FullMethodName = "/base.HistoryService/GetStudentHistory"
	HistoryService_GetHistoryDetail_FullMethodName  = "/base.HistoryService/GetHistoryDetail"
)

// HistoryServiceClient is the client API for HistoryService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type HistoryServiceClient interface {
	GetStudentHistory(ctx context.Context, in *StudentHistoryRequest, opts ...grpc.CallOption) (*StudentHistoryResponse, error)
	GetHistoryDetail(ctx context.Context, in *GetHistoryDetailRequest, opts ...grpc.CallOption) (*HistoryDetailResponse, error)
}

type historyServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewHistoryServiceClient(cc grpc.ClientConnInterface) HistoryServiceClient {
	return &historyServiceClient{cc}
}

func (c *historyServiceClient) GetStudentHistory(ctx context.Context, in *StudentHistoryRequest, opts ...grpc.CallOption) (*StudentHistoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StudentHistoryResponse)
	err := c.cc.Invoke(ctx, HistoryService_GetStudentHistory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *historyServiceClient) GetHistoryDetail(ctx context.Context, in *GetHistoryDetailRequest, opts ...grpc.CallOption) (*HistoryDetailResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HistoryDetailResponse)
	err := c.cc.Invoke(ctx, HistoryService_GetHistoryDetail_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// HistoryServiceServer is the server API for HistoryService service.
// All implementations must embed UnimplementedHistoryServiceServer
// for forward compatibility.
type HistoryServiceServer interface {
	GetStudentHistory(context.Context, *StudentHistoryRequest) (*StudentHistoryResponse, error)
	GetHistoryDetail(context.Context, *GetHistoryDetailRequest) (*HistoryDetailResponse, error)
	mustEmbedUnimplementedHistoryServiceServer()
}

// UnimplementedHistoryServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedHistoryServiceServer struct{}

func (UnimplementedHistoryServiceServer) GetStudentHistory(context.Context, *StudentHistoryRequest) (*StudentHistoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStudentHistory not implemented")
}
func (UnimplementedHistoryServiceServer) GetHistoryDetail(context.Context, *GetHistoryDetailRequest) (*HistoryDetailResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetHistoryDetail not implemented")
}
func (UnimplementedHistoryServiceServer) mustEmbedUnimplementedHistoryServiceServer() {}
func (UnimplementedHistoryServiceServer) testEmbeddedByValue()                        {}

// UnsafeHistoryServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to HistoryServiceServer will
// result in compilation errors.
type UnsafeHistoryServiceServer interface {
	mustEmbedUnimplementedHistoryServiceServer()
}

func RegisterHistoryServiceServer(s grpc.ServiceRegistrar, srv HistoryServiceServer) {
	// If the following call pancis, it indicates UnimplementedHistoryServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&HistoryService_ServiceDesc, srv)
}

func _HistoryService_GetStudentHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StudentHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HistoryServiceServer).GetStudentHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HistoryService_GetStudentHistory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HistoryServiceServer).GetStudentHistory(ctx, req.(*StudentHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HistoryService_GetHistoryDetail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetHistoryDetailRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HistoryServiceServer).GetHistoryDetail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HistoryService_GetHistoryDetail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HistoryServiceServer).GetHistoryDetail(ctx, req.(*GetHistoryDetailRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// HistoryService_ServiceDesc is the grpc.ServiceDesc for HistoryService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var HistoryService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "base.HistoryService",
	HandlerType: (*HistoryServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetStudentHistory",
			Handler:    _HistoryService_GetStudentHistory_Handler,
		},
		{
			MethodName: "GetHistoryDetail",
			Handler:    _HistoryService_GetHistoryDetail_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "template.proto",
}
